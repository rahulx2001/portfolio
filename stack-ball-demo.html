<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stack Ball - OPAC Games</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }
        #gameCanvas {
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="700"></canvas>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let ball = {
            x: canvas.width / 2,
            y: 100,
            radius: 25,
            velocity: 0,
            gravity: 0.5,
            bounceForce: -12,
            isSmashing: false
        };
        
        // Platform colors
        const colors = ['#00D4FF', '#00B4D8', '#0096C7', '#0077B6', '#023E8A', '#7B2CBF', '#9D4EDD'];
        const breakableColor = '#FF6B6B';
        
        // Platforms
        let platforms = [];
        let platformRotation = 0;
        let rotationSpeed = 0.02;
        
        // Particles for breaking effect
        let particles = [];
        
        // Game variables
        let score = 0;
        let showIntro = true;
        let introTimer = 0;
        let gameStarted = false;
        
        // Initialize platforms
        function initPlatforms() {
            platforms = [];
            for (let i = 0; i < 12; i++) {
                let segments = [];
                let numSegments = 8;
                let gapIndex = Math.floor(Math.random() * numSegments);
                let isBreakable = Math.random() > 0.6;
                
                for (let j = 0; j < numSegments; j++) {
                    if (j !== gapIndex) {
                        segments.push({
                            startAngle: (j / numSegments) * Math.PI * 2,
                            endAngle: ((j + 1) / numSegments) * Math.PI * 2 - 0.1,
                            broken: false
                        });
                    }
                }
                
                platforms.push({
                    y: 200 + i * 45,
                    radius: 120,
                    innerRadius: 40,
                    segments: segments,
                    color: isBreakable ? breakableColor : colors[i % colors.length],
                    isBreakable: isBreakable,
                    destroyed: false
                });
            }
        }
        
        // Create particles
        function createParticles(x, y, color) {
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 10 - 5,
                    size: Math.random() * 15 + 5,
                    color: color,
                    life: 1,
                    rotation: Math.random() * Math.PI * 2
                });
            }
        }
        
        // Draw OPAC Games logo
        function drawLogo(x, y, scale = 1) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);
            
            // Background rectangles (alternating colors)
            const bgColors = ['#FF6B6B', '#4ECDC4', '#FFE66D', '#95E1D3'];
            const rectWidth = 35;
            const rectHeight = 50;
            const totalWidth = rectWidth * 4;
            
            for (let i = 0; i < 4; i++) {
                ctx.fillStyle = bgColors[i];
                ctx.beginPath();
                ctx.roundRect(-totalWidth/2 + i * rectWidth, -rectHeight/2, rectWidth, rectHeight, i === 0 ? [8, 0, 0, 8] : i === 3 ? [0, 8, 8, 0] : 0);
                ctx.fill();
            }
            
            // OPAC text (white)
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('OPAC', 0, -5);
            
            // GAMES text (black)
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 12px Arial';
            ctx.fillText('GAMES', 0, 15);
            
            ctx.restore();
        }
        
        // Draw ball with 3D effect
        function drawBall() {
            ctx.save();
            
            // Ball shadow
            ctx.beginPath();
            ctx.ellipse(ball.x + 5, ball.y + 8, ball.radius * 0.8, ball.radius * 0.3, 0, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fill();
            
            // Main ball
            let gradient = ctx.createRadialGradient(
                ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, 0,
                ball.x, ball.y, ball.radius
            );
            gradient.addColorStop(0, '#FF8A8A');
            gradient.addColorStop(0.5, '#FF4757');
            gradient.addColorStop(1, '#C0392B');
            
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Highlight
            ctx.beginPath();
            ctx.arc(ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, ball.radius * 0.2, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.fill();
            
            // Smash effect
            if (ball.isSmashing) {
                ctx.beginPath();
                ctx.moveTo(ball.x, ball.y + ball.radius);
                ctx.lineTo(ball.x - 20, ball.y + ball.radius + 40);
                ctx.lineTo(ball.x + 20, ball.y + ball.radius + 40);
                ctx.closePath();
                
                let smashGradient = ctx.createLinearGradient(ball.x, ball.y + ball.radius, ball.x, ball.y + ball.radius + 40);
                smashGradient.addColorStop(0, 'rgba(255,255,255,0.8)');
                smashGradient.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = smashGradient;
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // Draw platforms
        function drawPlatforms() {
            platforms.forEach((platform, index) => {
                if (platform.destroyed) return;
                
                ctx.save();
                ctx.translate(canvas.width / 2, platform.y);
                
                platform.segments.forEach(segment => {
                    if (segment.broken) return;
                    
                    ctx.beginPath();
                    ctx.arc(0, 0, platform.radius, segment.startAngle + platformRotation, segment.endAngle + platformRotation);
                    ctx.arc(0, 0, platform.innerRadius, segment.endAngle + platformRotation, segment.startAngle + platformRotation, true);
                    ctx.closePath();
                    
                    // 3D effect
                    let gradient = ctx.createRadialGradient(0, 0, platform.innerRadius, 0, 0, platform.radius);
                    gradient.addColorStop(0, platform.color);
                    gradient.addColorStop(1, shadeColor(platform.color, -20));
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    ctx.strokeStyle = shadeColor(platform.color, -40);
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
                
                ctx.restore();
            });
        }
        
        // Helper function to shade colors
        function shadeColor(color, percent) {
            let R = parseInt(color.substring(1, 3), 16);
            let G = parseInt(color.substring(3, 5), 16);
            let B = parseInt(color.substring(5, 7), 16);
            
            R = parseInt(R * (100 + percent) / 100);
            G = parseInt(G * (100 + percent) / 100);
            B = parseInt(B * (100 + percent) / 100);
            
            R = Math.min(255, Math.max(0, R));
            G = Math.min(255, Math.max(0, G));
            B = Math.min(255, Math.max(0, B));
            
            return '#' + ((1 << 24) + (R << 16) + (G << 8) + B).toString(16).slice(1);
        }
        
        // Draw particles
        function drawParticles() {
            particles.forEach(p => {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.rotation);
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                ctx.restore();
            });
        }
        
        // Update particles
        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.5;
                p.life -= 0.02;
                p.rotation += 0.1;
                return p.life > 0;
            });
        }
        
        // Draw background
        function drawBackground() {
            let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#FFE259');
            gradient.addColorStop(1, '#FFA751');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Decorative elements
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.arc(50 + i * 80, 100 + Math.sin(Date.now() / 1000 + i) * 20, 30, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Draw score
        function drawScore() {
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(score, canvas.width / 2 + 2, 72);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(score, canvas.width / 2, 70);
        }
        
        // Draw intro screen
        function drawIntro() {
            // Darken background
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Logo
            drawLogo(canvas.width / 2, canvas.height / 2 - 50, 2);
            
            // Title
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('STACK BALL', canvas.width / 2, canvas.height / 2 + 50);
            
            // Subtitle
            ctx.font = '18px Arial';
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            ctx.fillText('Tap to Start', canvas.width / 2, canvas.height / 2 + 90);
            
            // Animated dots
            let dots = Math.floor((Date.now() / 500) % 4);
            ctx.fillText('.'.repeat(dots), canvas.width / 2 + 50, canvas.height / 2 + 90);
        }
        
        // Check collision
        function checkCollision() {
            platforms.forEach((platform, pIndex) => {
                if (platform.destroyed) return;
                
                if (ball.y + ball.radius > platform.y - 10 && ball.y + ball.radius < platform.y + 20) {
                    let dx = ball.x - canvas.width / 2;
                    let dy = 0;
                    let distance = Math.abs(dx);
                    
                    if (distance < platform.radius && distance > platform.innerRadius - 10) {
                        let ballAngle = Math.atan2(dy, dx);
                        if (ballAngle < 0) ballAngle += Math.PI * 2;
                        
                        let hitSegment = false;
                        platform.segments.forEach(segment => {
                            if (segment.broken) return;
                            
                            let startAngle = (segment.startAngle + platformRotation) % (Math.PI * 2);
                            let endAngle = (segment.endAngle + platformRotation) % (Math.PI * 2);
                            
                            if (startAngle < 0) startAngle += Math.PI * 2;
                            if (endAngle < 0) endAngle += Math.PI * 2;
                            
                            // Simplified collision check
                            if (ball.isSmashing || platform.isBreakable) {
                                segment.broken = true;
                                createParticles(ball.x, platform.y, platform.color);
                                score += 10;
                                hitSegment = true;
                            } else {
                                // Bounce
                                if (ball.velocity > 0) {
                                    ball.velocity = ball.bounceForce;
                                    hitSegment = true;
                                }
                            }
                        });
                        
                        // Check if all segments broken
                        if (platform.segments.every(s => s.broken)) {
                            platform.destroyed = true;
                        }
                    }
                }
            });
        }
        
        // Game loop
        function gameLoop() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background
            drawBackground();
            
            if (showIntro) {
                drawPlatforms();
                drawBall();
                drawIntro();
                
                introTimer++;
                if (introTimer > 180) { // Auto-start after 3 seconds
                    showIntro = false;
                    gameStarted = true;
                }
            } else {
                // Update game
                platformRotation += rotationSpeed;
                
                if (gameStarted) {
                    ball.velocity += ball.gravity;
                    ball.y += ball.velocity;
                    
                    // Auto smash for demo
                    if (Math.random() > 0.98) {
                        ball.isSmashing = !ball.isSmashing;
                    }
                    
                    // Keep ball in bounds
                    if (ball.y < 80) {
                        ball.y = 80;
                        ball.velocity = Math.abs(ball.velocity);
                    }
                    
                    // Move platforms up when ball goes down
                    if (ball.y > canvas.height / 2) {
                        let diff = ball.y - canvas.height / 2;
                        ball.y = canvas.height / 2;
                        platforms.forEach(p => p.y -= diff * 0.5);
                        
                        // Remove platforms that go off screen and add new ones
                        platforms = platforms.filter(p => p.y > -50);
                        
                        if (platforms.length < 12) {
                            let lastY = Math.max(...platforms.map(p => p.y));
                            let isBreakable = Math.random() > 0.6;
                            let segments = [];
                            let numSegments = 8;
                            let gapIndex = Math.floor(Math.random() * numSegments);
                            
                            for (let j = 0; j < numSegments; j++) {
                                if (j !== gapIndex) {
                                    segments.push({
                                        startAngle: (j / numSegments) * Math.PI * 2,
                                        endAngle: ((j + 1) / numSegments) * Math.PI * 2 - 0.1,
                                        broken: false
                                    });
                                }
                            }
                            
                            platforms.push({
                                y: lastY + 45,
                                radius: 120,
                                innerRadius: 40,
                                segments: segments,
                                color: isBreakable ? breakableColor : colors[Math.floor(Math.random() * colors.length)],
                                isBreakable: isBreakable,
                                destroyed: false
                            });
                        }
                    }
                    
                    checkCollision();
                    updateParticles();
                }
                
                // Draw elements
                drawPlatforms();
                drawParticles();
                drawBall();
                drawScore();
                
                // Draw logo in corner
                drawLogo(canvas.width - 60, 40, 0.8);
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Input handling
        canvas.addEventListener('mousedown', () => {
            if (showIntro) {
                showIntro = false;
                gameStarted = true;
            }
            ball.isSmashing = true;
        });
        
        canvas.addEventListener('mouseup', () => {
            ball.isSmashing = false;
        });
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (showIntro) {
                showIntro = false;
                gameStarted = true;
            }
            ball.isSmashing = true;
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            ball.isSmashing = false;
        });
        
        // Start
        initPlatforms();
        gameLoop();
    </script>
</body>
</html>
